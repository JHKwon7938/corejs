# corejs
# JS 예제 요약 정리

- **1-1**: 변수 선언만 한 상태
- **1-2**: 변수 선언과 초기화 방식 비교
- **1-3**: 변수 값 변경 및 참조 예시
- **1-4**: 객체 생성 예시
- **1-5**: 객체 프로퍼티 변경
- **1-6**: 배열 포함 객체 선언
- **1-7**: 원시값과 객체의 복사
- **1-8**: 원시값 복사와 객체 참조의 변화
- **1-9**: 객체를 새로운 객체로 재할당
- **1-10**: 얕은 복사로 인한 객체 변경
- **1-11**: 새로운 객체 리턴으로 참조 분리
- **1-12**: 얕은 복사 함수 정의
- **1-13**: 얕은 복사로 객체 변경 분리
- **1-14**: 중첩 객체 얕은 복사의 한계
- **1-15**: 중첩 객체 일부 복사 개선
- **1-16**: 깊은 복사 함수 정의
- **1-17**: 깊은 복사로 독립된 객체 생성
- **1-18**: JSON 방식의 깊은 복사 한계
- **1-19**: undefined와 ReferenceError 비교
- **1-20**: 배열의 빈 슬롯과 undefined 비교
- **1-21**: 배열 메서드 동작 비교
- **1-22**: null과 undefined 비교

- **2-1**: 함수 내부 변수 호이스팅 예제
- **2-2**: 매개변수와 변수 선언의 충돌
- **2-3**: 동일 변수 여러 번 선언의 영향
- **2-4**: 선언과 할당의 분리 구조 해석
- **2-5**: 변수와 함수 선언 충돌 사례
- **2-6**: 함수 선언이 우선되는 호이스팅
- **2-7**: 함수 표현식의 호이스팅 예외
- **2-8**: 함수 선언문과 표현식 차이
- **2-9**: 선언문은 호이스팅, 표현식은 불가
- **2-10**: 변수 선언과 함수 표현식의 구분
- **2-11**: 함수 중복 선언 시 덮어쓰기
- **2-12**: 함수 표현식은 호이스팅 불가
- **2-13**: 함수 내 중복 변수 선언의 영향
- **2-14**: 클로저의 함수 정보 출력
- **2-15**: 클로저에서 외부 변수 접근
- **2-16**: debugger로 클로저 확인

- **3-1**: 브라우저 환경의 this는 window
- **3-2**: Node.js 환경의 this는 global
- **3-3**: 전역 변수는 this의 프로퍼티
- **3-4**: window 객체와 전역 변수의 관계
- **3-5**: delete로 삭제 가능한 프로퍼티
- **3-6**: 함수 호출 위치에 따른 this
- **3-7**: 메서드 호출의 다양한 형태
- **3-8**: 중첩 객체의 메서드 this
- **3-9**: 함수 내부에서 this는 전역
- **3-10**: self로 this 유지
- **3-11**: 화살표 함수의 this 고정
- **3-12**: setTimeout, forEach, 이벤트에서의 this
- **3-13**: 생성자 함수와 인스턴스 생성
- **3-14**: call로 this 바인딩
- **3-15**: 메서드에 call 적용
- **3-16**: apply로 this 바인딩 및 배열 전달
- **3-17**: 유사 배열에 배열 메서드 적용
- **3-18**: arguments와 NodeList 변환
- **3-19**: 문자열에 배열 메서드 적용
- **3-20**: Array.from으로 유사 배열 변환
- **3-21**: 생성자 상속 구현
- **3-22**: 반복문 없이 최대/최소 구하기
- **3-23**: apply로 max/min 사용
- **3-24**: 전개 연산자로 max/min
- **3-25**: bind로 인자 고정
- **3-26**: bind 함수의 이름 확인
- **3-27**: call/bind로 내부 함수 this 지정
- **3-28**: setTimeout에서 bind를 통한 this 유지
- **3-29**: 화살표 함수로 내부 this 고정
- **3-30**: forEach 콜백에서 this 유지
- **3-31**: 고차 함수에서의 thisArg 인자

- **4-1**: 0.3초 간격으로 count를 출력하며 5가 되면 종료
- **4-2**: 콜백 함수로 count를 출력하며 5까지 증가
- **4-3**: 각 요소에 5를 더한 값을 반환하며 로그 출력
- **4-4**: map 인자가 잘못되어 예상치 못한 결과 발생
- **4-5**: map 함수를 직접 구현 (thisArg 지원 포함)
- **4-6**: setTimeout과 forEach는 전역 this, addEventListener는 DOM 요소 this
- **4-7**: 메서드 직접 호출은 this 유지, forEach는 this가 전역 객체
- **4-8**: 클로저로 this 바인딩 유지 후 출력
- **4-9**: setTimeout으로 전달하면 this가 바뀌지만 obj1.name 참조
- **4-10**: 함수를 바로 실행해 undefined 반환 → setTimeout에는 undefined 전달됨
- **4-11**: bind로 this를 명시적으로 고정
- **4-12**: 중첩 setTimeout으로 커피 이름들을 순차적으로 출력
- **4-13**: 함수 분리로 중첩을 줄인 커피 출력 시퀀스
- **4-14**: Promise 체인으로 순차 커피 이름 출력
- **4-15**: 커피 추가 함수를 커링 방식으로 체인 구성
- **4-16**: 제너레이터와 yield로 비동기 커피 이름 출력 흐름 구현
- **4-17**: async/await로 커피 순차 추가 및 출력

- **5-1**: 클로저로 외부 변수 a를 내부 함수에서 참조하고 변경
- **5-2**: 클로저 내부 함수 실행 결과를 외부로 반환
- **5-3**: 클로저 반환으로 내부 상태(a)를 외부에서 계속 유지
- **5-4**: setInterval/이벤트에서 클로저로 상태(a, count) 유지
- **5-5**: 클로저의 메모리 해제 방법 (return, clearInterval, removeEventListener)
- **5-6**: 클로저를 사용해 fruit 값을 click 이벤트에서 고정
- **5-7**: 클로저 없이 동일 함수 참조로 이벤트 연결 (값 고정 안됨)
- **5-8**: bind로 인자 바인딩하여 fruit 값을 고정
- **5-9**: 클로저 팩토리 함수로 각 fruit에 맞는 이벤트 핸들러 생성
- **5-10**: this 기반 자동차 객체로 내부 상태 (fuel, moved) 관리
- **5-11**: 클로저로 캡슐화된 자동차 객체 생성 (정보 은닉)
- **5-12**: Object.freeze로 자동차 객체의 외부 변경 방지
- **5-13**: bind로 함수에 일부 인자 미리 적용 (부분 적용 예시)
- **5-14**: 사용자 정의 partial 함수로 this 유지하며 부분 적용
- **5-15**: _ 자리 표시자로 인자를 유동적으로 바꾸는 partial2
- **5-16**: debounce로 연속 이벤트 발생 시 마지막만 실행되게 함
- **5-17**: 2단계 커링 함수로 인자 하나 고정한 함수 생성
- **5-18**: 5단계 커링 함수로 인자 순차 적용한 함수 생성

- **6-1**: 생성자 함수와 prototype 메서드 정의
- **6-2**: 생성자 함수와 인스턴스, prototype 속성 비교
- **6-3**: constructor 속성 확인 및 활용 예제
- **6-4**: 다양한 데이터 타입의 constructor 속성 오버라이딩 실험
- **6-5**: prototype과 constructor 속성을 활용한 인스턴스 생성
- **6-6**: 인스턴스의 메서드 오버라이딩
- **6-7**: 배열 요소에 대한 hasOwnProperty 확인
- **6-8**: 배열의 toString 메서드 오버라이딩
- **6-9**: 객체의 own 프로퍼티를 entries 형태로 추출하는 메서드 정의
- **6-10**: 유사 배열 객체 정의를 위한 생성자 함수 작성
  
- **7-1**: 정적 메서드는 인스턴스가 아닌 생성자 함수에서 호출
- **7-2**: 생성자 함수의 prototype을 배열로 지정해 배열처럼 동작
- **7-3**: prototype이 배열인 객체에 push 및 length 조작
- **7-4**: prototype이 배열인 객체의 length 삭제 시 동작 변화
- **7-5**: 사각형과 정사각형 클래스의 독립적 정의
- **7-6**: 정사각형에서 사각형 구조를 직접 재정의
- **7-7**: call과 prototype 재사용을 통한 상속 구현
- **7-8**: 객체 상속 패턴 extendClass1 구현
- **7-9**: 브릿지 패턴을 활용한 상속 패턴 extendClass2
- **7-10**: Object.create를 활용한 클래스 상속
- **7-11**: constructor 복원 포함한 extendClass1 개선
- **7-12**: 브릿지 패턴 extendClass2 개선 및 constructor 복원
- **7-13**: Object.create 방식 extendClass3로 간단 상속
- **7-14**: super 메서드 구현 및 부모 메서드 접근 가능하게 확장
- **7-15**: ES5/ES6 클래스의 static/instance 메서드 비교
- **7-16**: ES6 class와 extends 및 super를 활용한 상속
